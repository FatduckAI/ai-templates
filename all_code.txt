import { mkdir, rm } from "fs/promises";
import { tmpdir } from "os";
import { join } from "path";

export class TestSetup {
  private testDir: string;

  constructor() {
    // Create unique test directory name
    this.testDir = join(tmpdir(), `fatduck-test-${Date.now()}`);
  }

  async setup() {
    // Create test directory
    await mkdir(this.testDir, { recursive: true });
    process.chdir(this.testDir);
    return this.testDir;
  }

  async cleanup() {
    // Remove test directory and all contents
    await rm(this.testDir, { recursive: true, force: true });
  }

  getPath(...paths: string[]) {
    return join(this.testDir, ...paths);
  }
}
import { FatDuckCLI } from "../src/cli";
import { TestSetup } from "./helper";

async function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function runTests() {
  const cli = new FatDuckCLI();
  const testSetup = new TestSetup();
  const testDir = await testSetup.setup();

  console.log("\nüìÅ Created test directory:", testDir);

  try {
    // Initialize first
    console.log("\nüß™ Testing init command...");
    await cli.parse(["node", "fatduck", "init"]);
    await sleep(500);

    // Add telegram client
    console.log("\nüß™ Testing client addition...");
    process.stdout.write("\n"); // Add newline before spinner
    await cli.parse(["node", "fatduck", "add", "telegram", "-y"]);
    await sleep(500);

    // Add prompt
    console.log("\nüß™ Testing prompt addition...");
    process.stdout.write("\n"); // Add newline before spinner
    await cli.parse(["node", "fatduck", "add", "tweet", "-y"]);
    await sleep(500);

    // List components
    console.log("\nüß™ Testing list command...");
    process.stdout.write("\n"); // Add newline before spinner
    await cli.parse(["node", "fatduck", "list"]);
    await sleep(500); // Wait for list output to complete

    console.log("\n‚ú® All tests completed successfully!");
    console.log("\nüìÅ Test files are in:", testDir);
    console.log("To clean up run:");
    console.log(`rm -rf "${testDir}"`);
  } catch (error) {
    console.error("\n‚ùå Test failed:", error);
    process.exit(1);
  }
}

console.log("üöÄ Starting manual CLI tests...");
runTests().catch(console.error);
import { FatDuckCLI } from "./cli.js";

const cli = new FatDuckCLI();
cli.parse(process.argv);
import { Octokit } from "@octokit/rest";
import chalk from "chalk";
import { access, readFile, readdir } from "fs/promises";
import { join, resolve } from "path";

export class GitHubService {
  private octokit: Octokit;
  private readonly REPO_OWNER = "FatduckAI";
  private readonly REPO_NAME = "ai-templates";
  private readonly REPO_PATH = "packages/core/src";
  private readonly BRANCH = "master";
  private readonly LOCAL_PATH: string;
  private readonly DEBUG: boolean;

  // Map of file names to their kebab-case versions
  private readonly FILE_NAMES = {
    messageHandler: "message-handler",
    commandHandler: "command-handler",
    callbackHandler: "callback-handler",
  };

  constructor(options: { localPath?: string; debug?: boolean } = {}) {
    this.octokit = new Octokit();
    this.LOCAL_PATH =
      options.localPath || resolve(process.cwd(), "../../packages/core/src");
    this.DEBUG = options.debug || process.env.FATDUCK_DEBUG === "true" || false;
  }

  async getFile(componentPath: string): Promise<string> {
    // Special case for logic/index.ts
    if (componentPath === "clients/logic/index.ts") {
      if (this.DEBUG) {
        console.log(chalk.dim(`[DEBUG] Using default logic index template`));
      }
      return "export * from './messageHandler';\n// Export other handlers as they are added";
    }

    const componentName =
      componentPath.split("/").pop()?.replace(".ts", "") || componentPath;

    // Try to detect component type first
    const componentType = await this.detectComponentType(componentName);
    if (this.DEBUG) {
      console.log(
        chalk.dim(`[DEBUG] Detected component type: ${componentType}`)
      );
    }

    // Use the appropriate path based on component type
    let content: string | null = null;
    switch (componentType) {
      case "client":
        content = await this.tryPath(
          `clients/${componentName}/${componentName}.ts`
        );
        break;
      case "prompt":
        content =
          (await this.tryPath(`prompts/base/${componentName}.ts`)) ||
          (await this.tryPath(`prompts/specialized/${componentName}.ts`));
        break;
      case "tool":
        content = await this.tryPath(`tools/${componentName}.ts`);
        break;
    }

    if (content) {
      return content;
    }

    throw new Error(`Component "${componentName}" not found`);
  }

  private async detectComponentType(
    componentName: string
  ): Promise<"client" | "prompt" | "tool"> {
    // Try client first
    if (await this.exists(`clients/${componentName}`)) {
      return "client";
    }

    // Try prompt
    if (
      (await this.exists(`prompts/base/${componentName}.ts`)) ||
      (await this.exists(`prompts/specialized/${componentName}.ts`))
    ) {
      return "prompt";
    }

    // Try tool
    if (await this.exists(`tools/${componentName}.ts`)) {
      return "tool";
    }

    // Default to trying all paths
    return componentName.includes("client") ? "client" : "prompt";
  }

  private async exists(path: string): Promise<boolean> {
    try {
      const localPath = join(this.LOCAL_PATH, path);
      await access(localPath);
      return true;
    } catch {
      return false;
    }
  }

  private async tryPath(path: string): Promise<string | null> {
    try {
      // Try local path first
      const localPath = join(this.LOCAL_PATH, path);
      try {
        const content = await readFile(localPath, "utf-8");
        if (this.DEBUG) {
          console.log(
            chalk.dim(`[DEBUG] Found component in local path: ${localPath}`)
          );
        }
        return content;
      } catch {
        if (this.DEBUG) {
          console.log(
            chalk.dim(`[DEBUG] Not found in local path: ${localPath}`)
          );
        }
      }

      // Try GitHub
      if (this.DEBUG) {
        console.log(chalk.dim(`[DEBUG] Trying GitHub: ${path}`));
      }

      const response = await this.octokit.repos.getContent({
        owner: this.REPO_OWNER,
        repo: this.REPO_NAME,
        path: `${this.REPO_PATH}/${path}`,
        ref: this.BRANCH,
      });

      if ("content" in response.data) {
        if (this.DEBUG) {
          console.log(chalk.dim(`[DEBUG] Found component in GitHub: ${path}`));
        }
        return Buffer.from(response.data.content, "base64").toString();
      }
    } catch {
      return null;
    }
    return null;
  }

  async listDirectory(
    path: string
  ): Promise<Array<{ name: string; type: string; category?: string }>> {
    if (this.DEBUG) {
      console.log(chalk.dim(`[DEBUG] Listing directory: ${path}`));
    }

    const results = [];

    // Handle each type of component
    if (path === "prompts") {
      // List prompts
      const basePath = join(this.LOCAL_PATH, "prompts/base");
      const specializedPath = join(this.LOCAL_PATH, "prompts/specialized");

      try {
        const baseFiles = await readdir(basePath, { withFileTypes: true });
        results.push(
          ...baseFiles
            .filter(
              (file) =>
                file.isFile() &&
                file.name.endsWith(".ts") &&
                file.name !== "index.ts"
            )
            .map((file) => ({
              name: file.name.replace(".ts", ""),
              type: "prompt",
              category: "base",
            }))
        );
      } catch (error) {
        if (this.DEBUG) {
          console.log(
            chalk.dim(`[DEBUG] No base prompts found in: ${basePath}`)
          );
        }
      }

      try {
        const specializedFiles = await readdir(specializedPath, {
          withFileTypes: true,
        });
        results.push(
          ...specializedFiles
            .filter(
              (file) =>
                file.isFile() &&
                file.name.endsWith(".ts") &&
                file.name !== "index.ts"
            )
            .map((file) => ({
              name: file.name.replace(".ts", ""),
              type: "prompt",
              category: "specialized",
            }))
        );
      } catch (error) {
        if (this.DEBUG) {
          console.log(
            chalk.dim(
              `[DEBUG] No specialized prompts found in: ${specializedPath}`
            )
          );
        }
      }
    } else if (path === "clients") {
      // List clients
      const clientsPath = join(this.LOCAL_PATH, "clients");
      try {
        const entries = await readdir(clientsPath, { withFileTypes: true });
        results.push(
          ...entries
            .filter((entry) => entry.isDirectory() && entry.name !== "logic")
            .map((entry) => ({
              name: entry.name,
              type: "client",
            }))
        );
      } catch (error) {
        if (this.DEBUG) {
          console.log(chalk.dim(`[DEBUG] No clients found in: ${clientsPath}`));
        }
      }
    } else if (path === "tools") {
      // List tools
      const toolsPath = join(this.LOCAL_PATH, "tools");
      try {
        const files = await readdir(toolsPath, { withFileTypes: true });
        results.push(
          ...files
            .filter(
              (file) =>
                file.isFile() &&
                file.name.endsWith(".ts") &&
                file.name !== "index.ts"
            )
            .map((file) => ({
              name: file.name.replace(".ts", ""),
              type: "tool",
            }))
        );
      } catch (error) {
        if (this.DEBUG) {
          console.log(chalk.dim(`[DEBUG] No tools found in: ${toolsPath}`));
        }
      }
    }

    return results;
  }
}
import { exec } from "child_process";
import { access, constants } from "fs/promises";
import { Ora } from "ora";
import { join } from "path";
import { promisify } from "util";

const execAsync = promisify(exec);

export class PackageManagerService {
  async detect(): Promise<"bun" | "npm"> {
    try {
      await execAsync("bun -v");
      return "bun";
    } catch {
      return "npm";
    }
  }

  async initializePackageJson(spinner: Ora, packageManager: "bun" | "npm") {
    const packageJsonPath = join(process.cwd(), "package.json");
    try {
      await access(packageJsonPath, constants.F_OK);
      spinner.info("Found existing package.json");
    } catch {
      spinner.info(`Initializing package.json with ${packageManager}`);
      await execAsync(`${packageManager} init -y`);
    }
  }

  async installDependencies(
    spinner: Ora,
    packageManager: "bun" | "npm",
    dependencies: Record<string, string>
  ) {
    const depsArray = Object.entries(dependencies).map(
      ([name, version]) => `${name}@${version}`
    );
    const installCommand = packageManager === "bun" ? "bun add" : "npm install";

    spinner.start(`Installing dependencies with ${packageManager}`);
    try {
      await execAsync(`${installCommand} ${depsArray.join(" ")}`);
      spinner.succeed("Installed dependencies");
    } catch (error) {
      spinner.fail(`Failed to install dependencies with ${packageManager}`);
      throw error;
    }
  }
}
import chalk from "chalk";
import ora from "ora";
import { GitHubService } from "../services/github";

export class ListHandler {
  constructor(private github: GitHubService) {}

  async handle() {
    const spinner = ora({
      text: "Loading components...",
      spinner: "dots",
    }).start();

    try {
      // Get all components
      const prompts = await this.github.listDirectory("prompts");
      const tools = await this.github.listDirectory("tools");
      const clients = await this.github.listDirectory("clients");

      spinner.succeed("Components loaded successfully");

      if (!prompts.length && !tools.length && !clients.length) {
        console.log(chalk.yellow("\nNo components available"));
        return;
      }

      console.log("\nAvailable components:\n");

      if (prompts.length) {
        console.log(chalk.blue.bold("Prompts:"));
        prompts.forEach((prompt) => {
          const label = prompt.category ? ` (${prompt.category})` : "";
          console.log(`  ${chalk.green(prompt.name)}${chalk.dim(label)}`);
        });
      }

      if (tools.length) {
        console.log(chalk.blue.bold("\nTools:"));
        tools.forEach((tool) => {
          console.log(`  ${chalk.green(tool.name)}`);
        });
      }

      if (clients.length) {
        console.log(chalk.blue.bold("\nClients:"));
        clients.forEach((client) => {
          console.log(`  ${chalk.green(client.name)}`);
        });
        console.log(
          chalk.dim("\nAdd a client with:"),
          chalk.cyan("npx fatduck add <client-name>")
        );
      }
    } catch (error) {
      spinner.fail(`Failed to load components: ${(error as Error).message}`);
    }
  }
  private async getPrompts(): Promise<string[]> {
    try {
      const response = await this.github.listDirectory("prompts/base");
      return response
        .filter(
          (file) =>
            "name" in file && file.type === "file" && file.name.endsWith(".ts")
        )
        .map((file) => file.name.replace(".ts", ""));
    } catch {
      return [];
    }
  }

  private async getTools(): Promise<string[]> {
    try {
      const response = await this.github.listDirectory("tools");
      return response
        .filter(
          (file) =>
            "name" in file && file.type === "file" && file.name.endsWith(".ts")
        )
        .map((file) => file.name.replace(".ts", ""));
    } catch {
      return [];
    }
  }

  private async getClients(): Promise<string[]> {
    try {
      const response = await this.github.listDirectory("clients");
      const clients = [];

      for (const item of response) {
        if ("name" in item && item.type === "dir") {
          try {
            // Check if directory has a main client file
            await this.github.getFile(`clients/${item.name}/${item.name}.ts`);
            clients.push(item.name);
          } catch {
            // Skip if no main client file found
            continue;
          }
        }
      }

      return clients;
    } catch {
      return [];
    }
  }
}
import chalk from "chalk";
import { access, constants, mkdir, writeFile } from "fs/promises";
import ora, { Ora } from "ora";
import { dirname, join } from "path";
import prompts from "prompts";
import { GitHubService } from "../services/github";
import { PackageManagerService } from "../services/package-manager";

interface AddOptions {
  yes: boolean;
  force: boolean;
}

export class AddHandler {
  private readonly CLIENT_DEPENDENCIES: Record<string, Record<string, string>> =
    {
      telegram: { telegraf: "latest" },
      // Add other client dependencies here
    };

  constructor(
    private packageManager: PackageManagerService,
    private github: GitHubService
  ) {}

  async handle(componentName: string, options: AddOptions) {
    const spinner = ora({
      text: "Loading registry components...",
      spinner: "dots",
    }).start();

    try {
      // Check if it's a client first
      try {
        const clientFiles = await this.getClientFiles(componentName);
        await this.addClient(componentName, clientFiles, options, spinner);
        return;
      } catch (error) {
        // Not a client, continue with prompt/tool check
      }

      // Check for prompt or tool
      let content;
      let componentPath;

      try {
        content = await this.github.getFile(`prompts/base/${componentName}.ts`);
        componentPath = "prompts";
      } catch {
        try {
          content = await this.github.getFile(`tools/${componentName}.ts`);
          componentPath = "tools";
        } catch {
          spinner.fail(chalk.red(`Component "${componentName}" not found`));
          return;
        }
      }

      spinner.succeed(`Found ${componentName}`);

      if (!options.yes) {
        const response = await prompts({
          type: "confirm",
          name: "proceed",
          message: `Add ${componentName} to your project?`,
          initial: true,
        });

        if (!response.proceed) {
          console.log(chalk.yellow("Operation cancelled"));
          return;
        }
      }

      // Create directory
      const targetDir = `ai/${componentPath}`;
      await mkdir(targetDir, { recursive: true });

      // Check if file exists
      const filePath = join(process.cwd(), targetDir, `${componentName}.ts`);
      try {
        await access(filePath, constants.F_OK);
        if (!options.force) {
          const response = await prompts({
            type: "confirm",
            name: "override",
            message: `${componentName}.ts already exists. Override?`,
            initial: false,
          });

          if (!response.override) {
            console.log(chalk.yellow("Operation cancelled"));
            return;
          }
        }
      } catch {
        /* File doesn't exist, continue */
      }

      await writeFile(filePath, content);
      spinner.succeed(
        chalk.green(
          `Added ${componentName} to ${targetDir}/${componentName}.ts`
        )
      );
    } catch (error) {
      spinner.fail(chalk.red(`Failed to add ${componentName}`));
      console.error(error);
    }
  }

  private async getClientFiles(
    clientName: string
  ): Promise<Array<{ path: string; content: string }>> {
    const clientFiles = [];

    try {
      // Get the client implementation
      const clientContent = await this.github.getFile(
        `clients/${clientName}/${clientName}.ts`
      );
      clientFiles.push({
        path: `${clientName}.ts`,
        content: clientContent,
      });

      // Get associated handlers and utilities
      try {
        const handlersDir = await this.github.listDirectory(
          `clients/${clientName}/handlers`
        );

        for (const file of handlersDir) {
          if (
            "name" in file &&
            file.type === "file" &&
            file.name.endsWith(".ts")
          ) {
            const handlerContent = await this.github.getFile(
              `clients/${clientName}/handlers/${file.name}`
            );
            clientFiles.push({
              path: `handlers/${file.name}`,
              content: handlerContent,
            });
          }
        }
      } catch {
        // No handlers directory or other error, continue
      }

      return clientFiles;
    } catch (error) {
      throw new Error(`Client ${clientName} not found`);
    }
  }

  private async addClient(
    clientName: string,
    files: Array<{ path: string; content: string }>,
    options: AddOptions,
    spinner: Ora
  ) {
    try {
      spinner.succeed(`Found ${clientName} client template`);

      if (!options.yes) {
        const response = await prompts({
          type: "confirm",
          name: "proceed",
          message: `Add ${clientName} client to your project?`,
          initial: true,
        });

        if (!response.proceed) {
          console.log(chalk.yellow("Operation cancelled"));
          return;
        }
      }

      // Detect package manager
      const packageManager = await this.packageManager.detect();
      spinner.info(`Using ${packageManager} as package manager`);

      // Create client directory
      const clientDir = join(process.cwd(), "src/clients", clientName);
      await mkdir(clientDir, { recursive: true });
      await mkdir(join(clientDir, "handlers"), { recursive: true });

      // Write all files
      for (const file of files) {
        const filePath = join(clientDir, file.path);

        try {
          await access(filePath, constants.F_OK);
          if (!options.force) {
            const response = await prompts({
              type: "confirm",
              name: "override",
              message: `${filePath} already exists. Override?`,
              initial: false,
            });

            if (!response.override) {
              console.log(chalk.yellow(`Skipping ${filePath}`));
              continue;
            }
          }
        } catch {
          /* File doesn't exist, continue */
        }

        await mkdir(dirname(filePath), { recursive: true });
        await writeFile(filePath, file.content);
        spinner.succeed(chalk.green(`Added ${filePath}`));
      }

      // Install dependencies
      if (this.CLIENT_DEPENDENCIES[clientName]) {
        try {
          await this.packageManager.installDependencies(
            spinner,
            packageManager,
            this.CLIENT_DEPENDENCIES[clientName]
          );

          console.log(chalk.green(`\n${clientName} client added successfully`));

          // Show post-installation instructions
          if (clientName === "telegram") {
            console.log(chalk.yellow("\nDon't forget to:"));
            console.log("1. Set up your environment variables:");
            console.log(chalk.cyan("  TELEGRAM_BOT_TOKEN=your_bot_token_here"));
          }
        } catch (error) {
          spinner.fail("Failed to update dependencies");
          console.error(error);
        }
      }
    } catch (error) {
      spinner.fail(chalk.red(`Failed to add ${clientName} client`));
      console.error(error);
    }
  }
}
import chalk from "chalk";
import { mkdir, writeFile } from "fs/promises";
import ora, { Ora } from "ora";
import { join } from "path";
import { GitHubService } from "../services/github";
import { PackageManagerService } from "../services/package-manager";

export class InitHandler {
  constructor(
    private packageManager: PackageManagerService,
    private github: GitHubService
  ) {}

  async handle() {
    const spinner = ora({
      text: "Initializing FatDuck...",
      spinner: "dots",
    }).start();

    try {
      const pkgManager = await this.packageManager.detect();
      spinner.info(`Using ${pkgManager} as package manager`);

      await this.createDirectoryStructure();
      await this.packageManager.initializePackageJson(spinner, pkgManager);
      await this.createLogicIndex(spinner);

      spinner.succeed(chalk.green("FatDuck initialized successfully"));
      this.printDirectoryStructure();
    } catch (error) {
      spinner.fail(chalk.red("Failed to initialize FatDuck"));
      console.error(error);
    }
  }

  private async createDirectoryStructure() {
    await mkdir("ai/prompts", { recursive: true });
    await mkdir("ai/tools", { recursive: true });
    await mkdir("src/clients", { recursive: true });
    await mkdir("src/clients/logic", { recursive: true });
  }

  private async createLogicIndex(spinner: Ora) {
    try {
      const logicIndexContent = await this.github.getFile(
        "clients/logic/index.ts"
      );
      const logicIndexPath = join(process.cwd(), "src/clients/logic/index.ts");
      await writeFile(logicIndexPath, logicIndexContent);
    } catch (error) {
      spinner.warn("Could not fetch logic index template, using default");
      await writeFile(
        join(process.cwd(), "src/clients/logic/index.ts"),
        "export * from './messageHandler';\n// Export other handlers as they are added"
      );
    }
  }

  private printDirectoryStructure() {
    console.log("\nCreated directory structure:");
    console.log(
      chalk.cyan(`  ai/
  ‚îú‚îÄ‚îÄ prompts/
  ‚îî‚îÄ‚îÄ tools/
  src/
  ‚îú‚îÄ‚îÄ clients/
  ‚îÇ   ‚îú‚îÄ‚îÄ logic/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
  ‚îÇ   ‚îî‚îÄ‚îÄ telegram/`)
    );
  }
}
import chalk from "chalk";
import { Command } from "commander";
import { readFileSync } from "fs";
import { resolve } from "path";
import { AddHandler } from "./handlers/add";
import { InitHandler } from "./handlers/init";
import { ListHandler } from "./handlers/list";
import { GitHubService } from "./services/github";
import { PackageManagerService } from "./services/package-manager";

export class FatDuckCLI {
  private program: Command;
  private packageManager: PackageManagerService;
  private github: GitHubService;

  constructor() {
    this.program = new Command()
      .name("fatduck")
      .description(
        chalk.cyan("ü¶Ü Add AI prompts, tools, and clients to your project")
      )
      .version(this.getVersion());

    this.packageManager = new PackageManagerService();
    this.github = new GitHubService();

    this.setupCommands();
  }

  private getVersion(): string {
    const pkg = JSON.parse(
      readFileSync(resolve(__dirname, "../package.json"), "utf-8")
    );
    return pkg.version || "0.0.0";
  }

  private setupCommands() {
    this.program
      .command("init")
      .description("Initialize FatDuck in your project")
      .action(async () => {
        const handler = new InitHandler(this.packageManager, this.github);
        await handler.handle();
      });

    this.program
      .command("add <component>")
      .description("Add a prompt, tool, or client to your project")
      .option("-y, --yes", "Skip confirmation prompt", false)
      .option("-f, --force", "Override existing files", false)
      .action(async (componentName: string, options) => {
        const handler = new AddHandler(this.packageManager, this.github);
        await handler.handle(componentName, options);
      });

    this.program
      .command("list")
      .description("List all available components")
      .action(async () => {
        const handler = new ListHandler(this.github);
        await handler.handle();
      });
  }

  public async parse(args: string[]) {
    return this.program.parse(args);
  }
}
export interface RegistryItem {
  name: string;
  file: string;
  type: "prompt" | "tool";
  category?: "base" | "specialized";
  dependencies?: string[];
}

export interface Registry {
  [key: string]: RegistryItem;
}
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

async function updateDependencyVersion() {
  console.log("Running prepack script...");
  try {
    // Get the directory of the current script
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Construct absolute paths
    const packagePath = path.resolve(__dirname, "../package.json");
    console.log("CLI package.json path:", packagePath);

    const pkg = JSON.parse(await fs.readFile(packagePath, "utf8"));
    console.log(
      "Current @fatduckai/core version:",
      pkg.dependencies["@fatduckai/core"]
    );

    // Store the original version
    const workspaceVersionPath = path.resolve(__dirname, ".workspace-version");
    await fs.writeFile(
      workspaceVersionPath,
      pkg.dependencies["@fatduckai/core"]
    );

    // Try multiple possible locations for the core package.json
    const possibleCorePaths = [
      path.resolve(__dirname, "../../core/package.json"),
      path.resolve(__dirname, "../../../packages/core/package.json"),
      path.resolve(__dirname, "../../../core/package.json"),
      path.resolve(process.cwd(), "../core/package.json"),
      path.resolve(process.cwd(), "../../packages/core/package.json"),
    ];

    let corePkg;
    let foundCorePath;

    for (const corePath of possibleCorePaths) {
      try {
        console.log("Trying core package.json path:", corePath);
        const contents = await fs.readFile(corePath, "utf8");
        corePkg = JSON.parse(contents);
        foundCorePath = corePath;
        break;
      } catch (err) {
        console.log(`Not found at ${corePath}`);
        continue;
      }
    }

    if (!corePkg) {
      throw new Error(
        "Could not find core package.json in any expected location"
      );
    }

    console.log("Found core package.json at:", foundCorePath);

    // Update to the actual version for publishing
    pkg.dependencies["@fatduckai/core"] = corePkg.version;
    console.log(
      "Updated @fatduckai/core version:",
      pkg.dependencies["@fatduckai/core"]
    );

    await fs.writeFile(packagePath, JSON.stringify(pkg, null, 2));
    console.log("Prepack completed successfully");
  } catch (error) {
    console.error("Error in prepack script:", error);
    process.exit(1);
  }
}

updateDependencyVersion();
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

async function restoreWorkspaceVersion() {
  console.log("Running postpack script...");
  try {
    // Get the directory of the current script
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Construct absolute paths
    const packagePath = path.resolve(__dirname, "../package.json");
    const workspaceVersionPath = path.resolve(__dirname, ".workspace-version");

    const pkg = JSON.parse(await fs.readFile(packagePath, "utf8"));

    // Restore the workspace version
    const workspaceVersion = await fs.readFile(workspaceVersionPath, "utf8");
    console.log("Restoring workspace version:", workspaceVersion);

    pkg.dependencies["@fatduckai/core"] = workspaceVersion;

    await fs.writeFile(packagePath, JSON.stringify(pkg, null, 2));
    await fs.unlink(workspaceVersionPath);
    console.log("Postpack completed successfully");
  } catch (error) {
    console.error("Error in postpack script:", error);
    process.exit(1);
  }
}

restoreWorkspaceVersion();
import { execSync } from "child_process";
import fs from "fs/promises";
import path from "path";

async function buildCLI() {
  try {
    console.log("Starting build...");

    // Run bun build command
    execSync("bun build ./src/index.ts --outdir ./dist --target node", {
      stdio: "inherit",
    });

    console.log("Build completed, adding shebang...");

    // Add shebang to the output file
    const outputFile = path.join("./dist", "index.js");
    const content = await fs.readFile(outputFile, "utf8");
    await fs.writeFile(outputFile, `#!/usr/bin/env node\n${content}`);

    // Make it executable
    await fs.chmod(outputFile, 0o755);

    console.log("Build process completed successfully!");
  } catch (error) {
    console.error("Build failed:", error);
    process.exit(1);
  }
}

buildCLI();
import type { Config } from "tailwindcss";

export default {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
import type { NextConfig } from "next";

const nextConfig: NextConfig = {};

export default nextConfig;
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Utility for grouping items by category
export function groupByCategory<T extends { category: string }>(
  items: T[]
): Record<string, T[]> {
  return items.reduce((acc, item) => {
    if (!acc[item.category]) {
      acc[item.category] = [];
    }
    acc[item.category].push(item);
    return acc;
  }, {} as Record<string, T[]>);
}
import {
  isPrompt,
  RegistryItemType,
  SpecializedPrompt,
  Tool,
} from "@/types/registry";
import { getPromptById, getToolById } from "@fatduckai/core";

export async function getRegistryItem(
  type: string,
  id: string
): Promise<RegistryItemType | null> {
  try {
    if (type === "prompts") {
      return (await getPromptById(id)) || null;
    }

    if (type === "tools") {
      return (await getToolById(id)) || null;
    }

    return null;
  } catch (error) {
    console.error("Error fetching registry item:", error);
    return null;
  }
}

// Utility for grouping items by category
export function groupByCategory<T extends { category: string }>(
  items: T[]
): Record<string, T[]> {
  return items.reduce((acc, item) => {
    if (!acc[item.category]) {
      acc[item.category] = [];
    }
    acc[item.category].push(item);
    return acc;
  }, {} as Record<string, T[]>);
}

// Generates example usage code for prompts and tools
import { BaseAIItem } from "@/types/registry";

// Generates example usage code for prompts and tools
export function getUsageExample(
  item: BaseAIItem | SpecializedPrompt | Tool
): string {
  if (isPrompt(item)) {
    return `import { PromptBuilder } from '@fatduckai/ai'

const builder = new PromptBuilder(\`${item.template}\`)

// Example usage with variables
const result = await builder
  .withContext({
    ${Object.entries(item.variables || {})
      .map(([key]) => `${key}: "example-value"`)
      .join(",\n    ")}
  })
  .build()`;
  }

  if ("configSchema" in item) {
    const example = item.examples[0];
    return `import { ${item.name} } from '@/tools/${item.id}'

const result = await ${item.name}.handler({
  config: ${JSON.stringify(example?.config || {}, null, 2)}
})`;
  }

  return "";
}
import { FileText, Terminal, Wrench } from "lucide-react";
import Link from "next/link";

export function Features() {
  const features = [
    {
      title: "Prompts",
      description: "Pre-built prompt templates for common use cases.",
      icon: FileText,
      link: "/registry/prompts",
    },
    {
      title: "Tools",
      description:
        "Utility functions and integrations for enhancing AI responses.",
      icon: Wrench,
      link: "/registry/tools",
    },
    {
      title: "@fatduckai/ai",
      description:
        "A lightweight and efficient prompt builder npm package for parsing and linting prompts.",
      icon: Terminal,
      link: "https://github.com/FatduckAI/ai",
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 h-full">
      {features.map((feature) => (
        <Link
          href={feature.link}
          key={feature.title}
          className="h-full block group"
        >
          <div className="relative overflow-hidden rounded-lg border bg-background p-6 h-full flex flex-col transition-transform duration-300 ease-out transform group-hover:scale-105 items-center">
            <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-muted">
              <feature.icon className="h-6 w-6" />
            </div>
            <div className="flex flex-col flex-1">
              <h3 className="mt-4 text-lg font-medium">{feature.title}</h3>
              <p className="mt-2 text-muted-foreground">
                {feature.description}
              </p>
            </div>
          </div>
        </Link>
      ))}
    </div>
  );
}
"use client";

import { CopyBlock } from "@/components/copy-block";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { getUsageExample } from "@/lib/registry";
import { cn } from "@/lib/utils";
import { Tool } from "@/types/registry";
import { specializedPrompts, tools } from "@fatduckai/core";
import { ChevronDown, ChevronRight, ExternalLink } from "lucide-react";
import Link from "next/link";
import { useState } from "react";
import { z } from "zod";

interface ToolCardProps {
  toolId: string;
  showCompatibility?: boolean;
  className?: string;
}

// Helper function to get type name from Zod schema
function getSchemaType(schema: z.ZodType<any>): string {
  if (schema instanceof z.ZodString) return "string";
  if (schema instanceof z.ZodNumber) return "number";
  if (schema instanceof z.ZodBoolean) return "boolean";
  if (schema instanceof z.ZodEnum) {
    return schema._def.values.map((v: string) => `"${v}"`).join(" | ");
  }
  if (schema instanceof z.ZodArray) {
    const innerType = getSchemaType(schema._def.type);
    return `${innerType}[]`;
  }
  if (schema instanceof z.ZodObject) {
    return "object";
  }
  return "unknown";
}

export function ToolCard({
  toolId,
  showCompatibility = true,
  className,
}: ToolCardProps) {
  const [isOpen, setIsOpen] = useState(false);
  const tool = tools.find((t) => t.id === toolId);

  if (!tool) return null;

  return (
    <Card className={cn("overflow-hidden", className)}>
      <div className="p-4">
        <div className="flex items-start justify-between">
          <div>
            <div className="flex items-center gap-2">
              <h3 className="font-semibold">{tool.name}</h3>
              <Badge variant="outline">{tool.category}</Badge>
              {tool.version && (
                <Badge variant="secondary">v{tool.version}</Badge>
              )}
            </div>
            <p className="mt-1 text-sm text-muted-foreground">
              {tool.description}
            </p>
          </div>
          <Button variant="ghost" size="sm" asChild>
            <Link href={`/registry/tools/${tool.id}`}>
              <ExternalLink className="h-4 w-4" />
            </Link>
          </Button>
        </div>

        <Collapsible open={isOpen} onOpenChange={setIsOpen}>
          <CollapsibleTrigger asChild>
            <Button
              variant="ghost"
              size="sm"
              className="mt-2 w-full justify-start"
            >
              {isOpen ? (
                <ChevronDown className="mr-2 h-4 w-4" />
              ) : (
                <ChevronRight className="mr-2 h-4 w-4" />
              )}
              {isOpen ? "Hide" : "Show"} details
            </Button>
          </CollapsibleTrigger>
          <CollapsibleContent className="space-y-4">
            <div className="mt-4">
              <h4 className="text-sm font-medium mb-2">Quick Usage</h4>
              <CopyBlock
                content={getUsageExample(tool)}
                language="typescript"
                className="text-xs"
              />
            </div>

            <div>
              <h4 className="text-sm font-medium mb-2">Configuration</h4>
              <ConfigPreview schema={tool.configSchema} />
            </div>

            <div>
              <h4 className="text-sm font-medium mb-2">Output Type</h4>
              <OutputPreview schema={tool.outputSchema} />
            </div>

            {showCompatibility && <ToolCompatibility tool={tool} />}
          </CollapsibleContent>
        </Collapsible>
      </div>
    </Card>
  );
}

interface ConfigPreviewProps {
  schema: z.ZodType<any>;
}

function ConfigPreview({ schema }: ConfigPreviewProps) {
  const shape = schema instanceof z.ZodObject ? schema.shape : {};

  return (
    <div className="rounded-md bg-muted p-3">
      <code className="text-xs">
        {`interface Config {`}
        {Object.entries(shape).map(([key, value]) => (
          <div key={key} className="pl-2">
            {`${key}: ${getSchemaType(value as z.ZodType)}`}
          </div>
        ))}
        {`}`}
      </code>
    </div>
  );
}

function OutputPreview({ schema }: { schema: z.ZodType<any> }) {
  const shape = schema instanceof z.ZodObject ? schema.shape : {};

  return (
    <div className="rounded-md bg-muted p-3">
      <code className="text-xs">
        {`interface Output {`}
        {Object.entries(shape).map(([key, value]) => (
          <div key={key} className="pl-2">
            {`${key}: ${getSchemaType(value as z.ZodType)}`}
          </div>
        ))}
        {`}`}
      </code>
    </div>
  );
}

interface ToolCompatibilityProps {
  tool: Tool;
}

function ToolCompatibility({ tool }: ToolCompatibilityProps) {
  const compatiblePrompts = specializedPrompts.filter((p) =>
    p.suggestedTools.includes(tool.id)
  );

  if (compatiblePrompts.length === 0) return null;

  return (
    <div>
      <h4 className="text-sm font-medium mb-2">Compatible With</h4>
      <div className="space-y-2">
        {compatiblePrompts.map((prompt) => (
          <Link
            key={prompt.id}
            href={`/registry/prompts/${prompt.id}`}
            className="block"
          >
            <Card className="p-2 hover:bg-muted/50 transition-colors">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-sm font-medium">{prompt.name}</p>
                  <p className="text-xs text-muted-foreground">
                    Extends: {prompt.extends}
                  </p>
                </div>
                <ChevronRight className="h-4 w-4 text-muted-foreground" />
              </div>
            </Card>
          </Link>
        ))}
      </div>
    </div>
  );
}
// components/copy-block.tsx
"use client";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { Check, Copy, Terminal } from "lucide-react";
import Prism from "prismjs";
import "prismjs/components/prism-bash";
import "prismjs/components/prism-json";
import "prismjs/components/prism-markdown";
import "prismjs/components/prism-typescript";
import "prismjs/themes/prism-tomorrow.css"; // You can choose different themes
import * as React from "react";

interface CopyBlockProps {
  content: string;
  language?: string;
  className?: string;
  showLineNumbers?: boolean;
  variant?: "default" | "terminal";
}

export function CopyBlock({
  content,
  language = "typescript",
  className,
  showLineNumbers = false,
  variant = "default",
}: CopyBlockProps) {
  const [copied, setCopied] = React.useState(false);
  const timeoutRef = React.useRef<NodeJS.Timeout>();

  React.useEffect(() => {
    Prism.highlightAll();
  }, [content]);

  async function copyToClipboard() {
    try {
      await navigator.clipboard.writeText(content);
      setCopied(true);

      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        setCopied(false);
      }, 2000);
    } catch (error) {
      console.error("Failed to copy content:", error);
    }
  }

  return (
    <div
      className={cn(
        "relative overflow-hidden rounded-lg",
        variant === "terminal" ? "bg-zinc-950" : "bg-zinc-950",
        className
      )}
    >
      {variant === "terminal" && (
        <div className="flex items-center gap-1 px-4 py-2 bg-zinc-800">
          <div className="w-2 h-2 rounded-full bg-red-500" />
          <div className="w-2 h-2 rounded-full bg-yellow-500" />
          <div className="w-2 h-2 rounded-full bg-green-500" />
          <Terminal className="w-4 h-4 ml-2 text-zinc-400" />
        </div>
      )}

      <div className="relative group">
        <pre
          className={cn(
            "p-4 overflow-x-auto",
            showLineNumbers && "line-numbers",
            variant === "terminal" && "bg-transparent"
          )}
        >
          <code className={`language-${language}`}>{content}</code>
        </pre>

        <Button
          size="icon"
          variant="ghost"
          className={cn(
            "absolute right-4 top-4 opacity-0 transition-opacity",
            "group-hover:opacity-100",
            "h-6 w-6",
            copied && "text-green-500"
          )}
          onClick={copyToClipboard}
        >
          {copied ? (
            <Check className="h-3 w-3" />
          ) : (
            <Copy className="h-3 w-3" />
          )}
          <span className="sr-only">Copy code</span>
        </Button>
      </div>
    </div>
  );
}

// Add these styles to your globals.css
/*

*/
import { Badge } from "@/components/ui/badge";
import { Card } from "@/components/ui/card";
import { groupByCategory } from "@/lib/utils";
import { basePrompts, specializedPrompts, tools } from "@fatduckai/core";
import Link from "next/link";

export function RegistryOverview() {
  return (
    <div className="space-y-8">
      <section>
        <h2 className="text-2xl font-bold mb-4">Base Prompts</h2>
        <div className="grid gap-4 md:grid-cols-2">
          {basePrompts.map((prompt) => (
            <Link key={prompt.id} href={`/registry/prompts/${prompt.id}`}>
              <Card className="p-4 hover:bg-muted/50 transition-colors">
                <h3 className="font-medium mb-1">{prompt.name}</h3>
                <p className="text-sm text-muted-foreground mb-2">
                  {prompt.description}
                </p>
                <div className="flex gap-2">
                  <Badge>base</Badge>
                  {prompt.version && (
                    <Badge variant="outline">v{prompt.version}</Badge>
                  )}
                </div>
              </Card>
            </Link>
          ))}
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-bold mb-4">Specialized Prompts</h2>
        <div className="grid gap-4 md:grid-cols-2">
          {specializedPrompts.map((prompt) => (
            <Link key={prompt.id} href={`/registry/prompts/${prompt.id}`}>
              <Card className="p-4 hover:bg-muted/50 transition-colors">
                <h3 className="font-medium mb-1">{prompt.name}</h3>
                <p className="text-sm text-muted-foreground mb-2">
                  {prompt.description}
                </p>
                <div className="flex gap-2">
                  <Badge variant="secondary">specialized</Badge>
                  <Badge variant="outline">extends: {prompt.extends}</Badge>
                </div>
              </Card>
            </Link>
          ))}
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-bold mb-4">Tools</h2>
        {Object.entries(groupByCategory(tools)).map(
          ([category, categoryTools]) => (
            <div key={category} className="mb-6">
              <h3 className="text-lg font-medium mb-3 capitalize">
                {category}
              </h3>
              <div className="grid gap-4 md:grid-cols-2">
                {categoryTools.map((tool) => (
                  <Link key={tool.id} href={`/registry/tools/${tool.id}`}>
                    <Card className="p-4 hover:bg-muted/50 transition-colors">
                      <h4 className="font-medium mb-1">{tool.name}</h4>
                      <p className="text-sm text-muted-foreground mb-2">
                        {tool.description}
                      </p>
                      <Badge variant="outline">{category}</Badge>
                    </Card>
                  </Link>
                ))}
              </div>
            </div>
          )
        )}
      </section>
    </div>
  );
}
"use client";

import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import Link from "next/link";
import { usePathname } from "next/navigation";

interface DocsSidebarProps {
  items: {
    title: string;
    items: {
      title: string;
      href: string;
      description?: string;
      badge?: string;
      isCategory?: boolean;
    }[];
  }[];
}

export function DocsSidebar({ items }: DocsSidebarProps) {
  const pathname = usePathname();

  return (
    <div className="w-full">
      {items.map((section) => (
        <div key={section.title} className="py-8">
          <h4 className="mb-2 text-sm font-semibold">{section.title}</h4>
          <div className="grid grid-flow-row auto-rows-max gap-2">
            {section.items.map((item) =>
              item.isCategory ? (
                <h5
                  key={item.title}
                  className="mt-4 mb-2 px-2 text-sm font-medium text-muted-foreground"
                >
                  {item.title}
                </h5>
              ) : (
                <Link
                  key={item.href}
                  href={item.href}
                  className={cn(
                    "flex flex-col gap-1 rounded-md p-2 hover:bg-muted",
                    pathname === item.href
                      ? "bg-muted font-medium text-foreground"
                      : "text-muted-foreground"
                  )}
                >
                  <div className="flex items-center justify-between">
                    <span>{item.title}</span>
                    {item.badge && (
                      <Badge
                        variant={
                          item.badge.startsWith("extends")
                            ? "outline"
                            : "default"
                        }
                        className="text-xs"
                      >
                        {item.badge}
                      </Badge>
                    )}
                  </div>
                  {item.description && (
                    <span className="text-xs text-muted-foreground line-clamp-2">
                      {item.description}
                    </span>
                  )}
                </Link>
              )
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
"use client";

import { useTheme } from "@/components/theme-provider";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Moon, Sun } from "lucide-react";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
import { CopyBlock } from "@/components/copy-block";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { getUsageExample } from "@/lib/registry";
import {
  RegistryItemType,
  isPrompt,
  isSpecializedPrompt,
} from "@/types/registry";
import { PromptEditor } from "./prompt-editor";
import { ToolCard } from "./tool-card";

interface RegistryItemProps {
  item: RegistryItemType;
}

export function RegistryItem({ item }: RegistryItemProps) {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">{item.name}</h1>
          <p className="text-lg text-muted-foreground">{item.description}</p>
        </div>
        <div className="flex items-center gap-2">
          <Badge variant={item.type === "base" ? "default" : "secondary"}>
            {item.type}
          </Badge>
          {item.version && <Badge variant="outline">v{item.version}</Badge>}
        </div>
      </div>

      <Tabs defaultValue="usage">
        <TabsList>
          <TabsTrigger value="usage">Usage</TabsTrigger>
          {isPrompt(item) && <TabsTrigger value="editor">Editor</TabsTrigger>}
          <TabsTrigger value="examples">Examples</TabsTrigger>
          {isSpecializedPrompt(item) && (
            <TabsTrigger value="tools">Compatible Tools</TabsTrigger>
          )}
        </TabsList>

        <TabsContent value="usage" className="space-y-4">
          <div className="rounded-md border p-4">
            <h3 className="mb-2 font-medium">Installation</h3>
            <CopyBlock
              content={`npx prompt-tools add ${item.type} ${item.id}`}
              language="bash"
            />
          </div>

          <div className="rounded-md border p-4">
            <h3 className="mb-2 font-medium">Code Example</h3>
            <CopyBlock content={getUsageExample(item)} language="typescript" />
          </div>
        </TabsContent>

        {isPrompt(item) && (
          <TabsContent value="editor">
            <PromptEditor item={item} />
          </TabsContent>
        )}

        <TabsContent value="examples" className="space-y-4">
          {item.examples.map((example, index) => (
            <div key={index} className="rounded-md border p-4">
              <h3 className="mb-2 font-medium">Example {index + 1}</h3>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <h4 className="text-sm font-medium">Input</h4>
                  <CopyBlock
                    content={JSON.stringify(
                      "input" in example ? example.input : example.config,
                      null,
                      2
                    )}
                    language="json"
                  />
                </div>
                <div>
                  <h4 className="text-sm font-medium">Output</h4>
                  <CopyBlock
                    content={JSON.stringify(
                      "output" in example ? example.output : example.result,
                      null,
                      2
                    )}
                    language="json"
                  />
                </div>
              </div>
            </div>
          ))}
        </TabsContent>

        {isSpecializedPrompt(item) && (
          <TabsContent value="tools" className="space-y-4">
            {item.suggestedTools.map((toolId) => (
              <ToolCard key={toolId} toolId={toolId} />
            ))}
          </TabsContent>
        )}
      </Tabs>
    </div>
  );
}
import { Features } from "./features";

export function Hero() {
  return (
    <div className="container py-16 md:py-24">
      <div className="text-center">
        <h1 className="text-4xl font-bold tracking-tight sm:text-6xl">
          Prompts & Tools for LLMs
        </h1>
        <p className="mt-6 text-lg leading-8 text-muted-foreground max-w-2xl mx-auto">
          A collection of reusable prompts and tools for building AI
          applications. Easily copy and paste into your projects.
        </p>
        <div className="mt-10 flex items-center justify-center gap-x-6 mx-auto h-full">
          <Features />
        </div>
      </div>
    </div>
  );
}
import { groupByCategory } from "@/lib/utils";
import { basePrompts, specializedPrompts, tools } from "@fatduckai/core";
import { DocsSidebar } from "./sidebar";

interface DocLayoutProps {
  children: React.ReactNode;
}

export function DocLayout({ children }: DocLayoutProps) {
  // Group tools by category
  const toolsByCategory = groupByCategory(tools);

  const sidebarItems = [
    {
      title: "Prompts",
      items: [
        // Base prompts
        ...basePrompts.map((prompt) => ({
          title: prompt.name,
          href: `/registry/prompts/${prompt.id}`,
          description: prompt.description,
          badge: "base",
        })),
        // Specialized prompts
        ...specializedPrompts.map((prompt) => ({
          title: prompt.name,
          href: `/registry/prompts/${prompt.id}`,
          description: prompt.description,
          badge: `extends: ${prompt.extends}`,
        })),
      ],
    },
    {
      title: "Tools",
      items: Object.entries(toolsByCategory).flatMap(
        ([category, categoryTools]) => [
          // Add category header
          {
            title: category,
            href: "#",
            isCategory: true,
          },
          // Add tools in this category
          ...categoryTools.map((tool) => ({
            title: tool.name,
            href: `/registry/tools/${tool.id}`,
            description: tool.description,
          })),
        ]
      ),
    },
  ];

  return (
    <div className="container flex-1 items-start md:grid md:grid-cols-[220px_1fr] md:gap-6 lg:grid-cols-[240px_1fr] lg:gap-10">
      <aside className="fixed top-14 z-30 -ml-2 hidden h-[calc(100vh-3.5rem)] w-full shrink-0 md:sticky md:block">
        <DocsSidebar items={sidebarItems} />
      </aside>
      <main className="relative py-6 lg:gap-10 lg:py-8 xl:grid">
        <div className="mx-auto w-full min-w-0">{children}</div>
      </main>
    </div>
  );
}
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { basePrompts, specializedPrompts, tools } from "@fatduckai/core";
import { ChevronDown } from "lucide-react";
import Image from "next/image";
import Link from "next/link";

export function MainNav() {
  return (
    <div className="mr-4 hidden md:flex">
      <Link href="/" className="mr-6 flex items-center space-x-2">
        <Image src="/tinyDucky.png" alt="AI Templates" width={32} height={32} />
        <span className="hidden font-bold sm:inline-block">AI Templates</span>
      </Link>
      <nav className="flex items-center space-x-6 text-sm font-medium">
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              variant="ghost"
              className="h-8 w-full justify-start space-x-2 px-2 py-1"
            >
              <span>Prompts</span>
              <ChevronDown className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent className="w-56">
            <DropdownMenuGroup>
              <DropdownMenuItem className="font-semibold">
                Base Prompts
              </DropdownMenuItem>
              {basePrompts.map((prompt) => (
                <DropdownMenuItem key={prompt.id}>
                  <Link
                    href={`/registry/prompts/${prompt.id}`}
                    className="w-full"
                  >
                    {prompt.name}
                  </Link>
                </DropdownMenuItem>
              ))}
              <DropdownMenuItem className="font-semibold">
                Specialized Prompts
              </DropdownMenuItem>
              {specializedPrompts.map((prompt) => (
                <DropdownMenuItem key={prompt.id}>
                  <Link
                    href={`/registry/prompts/${prompt.id}`}
                    className="w-full"
                  >
                    {prompt.name}
                  </Link>
                </DropdownMenuItem>
              ))}
            </DropdownMenuGroup>
          </DropdownMenuContent>
        </DropdownMenu>

        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              variant="ghost"
              className="h-8 w-full justify-start space-x-2 px-2 py-1"
            >
              <span>Tools</span>
              <ChevronDown className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent className="w-56">
            <DropdownMenuGroup>
              {Object.entries(
                tools.reduce((acc, tool) => {
                  if (!acc[tool.category]) {
                    acc[tool.category] = [];
                  }
                  acc[tool.category].push(tool);
                  return acc;
                }, {} as Record<string, typeof tools>)
              ).map(([category, categoryTools]) => (
                <DropdownMenuGroup key={category}>
                  <DropdownMenuItem className="font-semibold">
                    {category}
                  </DropdownMenuItem>
                  {categoryTools.map((tool) => (
                    <DropdownMenuItem key={tool.id}>
                      <Link
                        href={`/registry/tools/${tool.id}`}
                        className="w-full"
                      >
                        {tool.name}
                      </Link>
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuGroup>
              ))}
            </DropdownMenuGroup>
          </DropdownMenuContent>
        </DropdownMenu>
      </nav>
    </div>
  );
}
"use client";

import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeProviderProps = {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
};

type ThemeProviderState = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const ThemeProviderContext = createContext<ThemeProviderState | undefined>(
  undefined
);

export function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "ui-theme",
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(defaultTheme);

  // Handle initial theme setup after mounting
  useEffect(() => {
    const savedTheme = localStorage.getItem(storageKey) as Theme;
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, [storageKey]);

  useEffect(() => {
    const root = window.document.documentElement;

    root.classList.remove("light", "dark");

    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
        .matches
        ? "dark"
        : "light";

      root.classList.add(systemTheme);
      return;
    }

    root.classList.add(theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme);
      setTheme(theme);
    },
  };

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  );
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);

  if (context === undefined)
    throw new Error("useTheme must be used within a ThemeProvider");

  return context;
};
import { CommandMenu } from "@/components/command-menu";
import { MainNav } from "@/components/main-nav";
import { ModeToggle } from "@/components/mode-toggle";
import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import Link from "next/link";
import { Icons } from "./icons";

export function SiteHeader() {
  return (
    <header className="sticky top-0 z-50 w-full border-b border-border/40 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-14 max-w-screen-2xl items-center">
        <MainNav />
        <div className="flex flex-1 items-center justify-between space-x-2 md:justify-end">
          <div className="w-full flex-1 md:w-auto md:flex-none">
            <CommandMenu />
          </div>
          <nav className="flex items-center space-x-2">
            {/* <Link
              href="/registry"
              className={cn(
                buttonVariants({ variant: "ghost", size: "sm" }),
                "w-9 px-0"
              )}
            >
              Registry
            </Link>
            <Link
              href="/docs"
              className={cn(
                buttonVariants({ variant: "ghost", size: "sm" }),
                "w-9 px-0"
              )}
            >
              Docs
            </Link> */}
            <Link
              href="https://github.com/yourusername/prompt-tools"
              className={cn(
                buttonVariants({ variant: "ghost", size: "sm" }),
                "w-9 px-0"
              )}
              target="_blank"
              rel="noreferrer"
            >
              <Icons.gitHub className="h-4 w-4" />
              <span className="sr-only">GitHub</span>
            </Link>
            <ModeToggle />
          </nav>
        </div>
      </div>
    </header>
  );
}
"use client";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { cn } from "@/lib/utils";
import { BaseAIItem, SpecializedPrompt } from "@/types/registry";
import { PromptBuilder } from "@fatduckai/ai";
import { AlertTriangle, Check } from "lucide-react";
import { useEffect, useState } from "react";

interface PromptEditorProps {
  item: BaseAIItem | SpecializedPrompt;
  className?: string;
  onUpdate?: (template: string) => void;
}

function extractVariables(template: string): string[] {
  const variableRegex = /<([^>]+)>/g;
  const matches = template.match(variableRegex) || [];
  return matches
    .map((match) => match.replace(/<|>/g, ""))
    .filter(
      (name) =>
        ![
          "system",
          "user",
          "assistant",
          "/system",
          "/user",
          "/assistant",
        ].includes(name)
    )
    .filter((name, index, self) => self.indexOf(name) === index);
}

export function PromptEditor({ item, className, onUpdate }: PromptEditorProps) {
  const [template, setTemplate] = useState(item.template);
  const [variables, setVariables] = useState<Record<string, string>>({});
  const [allowEmptyContent, setAllowEmptyContent] = useState(true);
  const [validation, setValidation] = useState<{
    isValid: boolean;
    errors: string[];
    warnings: string[];
  }>({
    isValid: true,
    errors: [],
    warnings: [],
  });
  const [output, setOutput] = useState<Array<{
    role: string;
    content: string;
  }> | null>(null);

  useEffect(() => {
    const extractedVars = extractVariables(template);
    const newVars: Record<string, string> = {};
    const exampleValues = item.examples[0]?.input || {};

    extractedVars.forEach((name) => {
      newVars[name] =
        variables[name] ||
        exampleValues[name]?.toString() ||
        "" ||
        getDefaultForVariable(name);
    });

    setVariables(newVars);
  }, [template]);

  function getDefaultForVariable(name: string): string {
    const example = item.examples[0]?.input || {};

    if (name in example) {
      return String(example[name]);
    }

    switch (name) {
      case "tone":
        return "professional";
      case "includeHashtags":
        return "true";
      case "includeEmojis":
        return "true";
      case "topic":
        return "artificial intelligence";
      case "task":
        return "writing code";
      case "name":
        return "Alice";
      case "btc_price":
        return "45000.00";
      case "market_sentiment":
        return "bullish";
      case "priceEmphasis":
        return "high";
      default:
        return `[${name}]`;
    }
  }

  const handleTemplateChange = (newTemplate: string) => {
    setTemplate(newTemplate);
    onUpdate?.(newTemplate);
  };

  const handleVariableChange = (name: string, value: string) => {
    setVariables((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleVerify = async () => {
    try {
      console.log("template", template);
      const builder = new PromptBuilder(template, {
        allowEmptyContent,
      }).withContext(variables);
      console.log("variables", variables);

      const validationResult = await builder.validate();
      console.log("validationResult", validationResult);
      const missingVars = extractVariables(template).filter(
        (name) =>
          !variables[name] && !["system", "user", "assistant"].includes(name)
      );

      if (!validationResult.isValid) {
        validationResult.errors.push(
          `Variables not defined: ${missingVars.join(", ")}`
        );
      }

      setValidation(validationResult);

      if (validationResult.isValid) {
        const messages = await builder.withContext(variables).build();
        setOutput(messages);
      }
    } catch (error) {
      setValidation({
        isValid: false,
        errors: [error instanceof Error ? error.message : "Unknown error"],
        warnings: [],
      });
    }
  };

  return (
    <Card className={cn("w-full", className)}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Template Editor</CardTitle>
          <Badge variant={validation.isValid ? "default" : "destructive"}>
            {validation.isValid ? "Valid" : "Invalid"}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="space-y-4">
          <div className="flex items-center space-x-2">
            <Switch
              id="allow-empty"
              checked={allowEmptyContent}
              onCheckedChange={setAllowEmptyContent}
            />
            <Label htmlFor="allow-empty">Allow Empty Content</Label>
          </div>

          <textarea
            value={template}
            onChange={(e) => handleTemplateChange(e.target.value)}
            className="w-full h-64 p-4 font-mono text-sm rounded-md border bg-background resize-none"
            placeholder="Enter prompt template..."
          />

          {Object.keys(variables).length > 0 && (
            <div className="grid gap-4 md:grid-cols-2">
              {Object.entries(variables).map(([name, value]) => (
                <div key={name} className="flex gap-2 items-center">
                  <label className="text-sm font-medium min-w-[100px]">
                    {name}:
                  </label>
                  <input
                    type="text"
                    value={value}
                    onChange={(e) => handleVariableChange(name, e.target.value)}
                    className="flex-1 p-2 text-sm rounded-md border bg-background"
                    placeholder={`Enter ${name}...`}
                  />
                </div>
              ))}
            </div>
          )}

          {validation.errors.length > 0 && (
            <div className="flex items-start gap-2 text-destructive">
              <AlertTriangle className="h-4 w-4 mt-0.5" />
              <ul className="text-sm space-y-1">
                {validation.errors.map((error, i) => (
                  <li key={i}>{error}</li>
                ))}
              </ul>
            </div>
          )}

          <Button onClick={handleVerify} className="w-full">
            <Check className="mr-2 h-4 w-4" />
            Verify Template
          </Button>
        </div>

        {output && (
          <div className="space-y-2">
            <h3 className="text-sm font-medium">Preview</h3>
            <pre className="p-4 rounded-md bg-muted overflow-auto max-h-96 whitespace-pre-wrap break-all">
              <code className="text-sm">{JSON.stringify(output, null, 2)}</code>
            </pre>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import Link from "next/link";

interface NavItemProps {
  item: {
    href: string;
    label: string;
    badge?: string;
    icon?: React.ComponentType<{ className?: string }>;
    description?: string;
  };
  active?: boolean;
}

export function NavItem({ item, active }: NavItemProps) {
  const Icon = item.icon;

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Link
            href={item.href}
            className={cn(
              "flex items-center gap-2 rounded-lg px-3 py-2 text-sm transition-colors hover:bg-muted",
              active && "bg-muted font-medium"
            )}
          >
            {Icon && <Icon className="h-4 w-4" />}
            <span className="truncate">{item.label}</span>
            {item.badge && (
              <Badge variant="outline" className="ml-auto">
                {item.badge}
              </Badge>
            )}
          </Link>
        </TooltipTrigger>
        {item.description && (
          <TooltipContent side="right" className="max-w-[300px]">
            <p>{item.description}</p>
          </TooltipContent>
        )}
      </Tooltip>
    </TooltipProvider>
  );
}
import {
  AlertTriangle,
  ArrowRight,
  Check,
  ChevronLeft,
  ChevronRight,
  Command,
  CreditCard,
  FileText,
  Github,
  HelpCircle,
  Laptop,
  Loader2,
  LucideIcon,
  Moon,
  MoreVertical,
  Pizza,
  Plus,
  Settings,
  SunMedium,
  Trash,
  Twitter,
  User,
  X,
} from "lucide-react";

export type Icon = LucideIcon;

export const Icons = {
  logo: Command,
  close: X,
  spinner: Loader2,
  chevronLeft: ChevronLeft,
  chevronRight: ChevronRight,
  trash: Trash,
  settings: Settings,
  user: User,
  arrowRight: ArrowRight,
  help: HelpCircle,
  pizza: Pizza,
  sun: SunMedium,
  moon: Moon,
  laptop: Laptop,
  gitHub: Github,
  twitter: Twitter,
  check: Check,
  warning: AlertTriangle,
  fileText: FileText,
  plus: Plus,
  creditCard: CreditCard,
  moreVertical: MoreVertical,
} as const;
"use client";

import { CreditCard, Search, Settings } from "lucide-react";
import { useRouter } from "next/navigation";
import * as React from "react";

import { Button } from "@/components/ui/button";
import {
  CommandItem,
  CommandDialog as ShadcnCommandDialog,
  CommandEmpty as ShadcnCommandEmpty,
  CommandGroup as ShadcnCommandGroup,
  CommandInput as ShadcnCommandInput,
  CommandItem as ShadcnCommandItem,
  CommandList as ShadcnCommandList,
  CommandSeparator as ShadcnCommandSeparator,
} from "@/components/ui/command";

interface Tool {
  name: string;
  category: string;
  description: string;
  href: string;
}

interface Prompt {
  name: string;
  category: string;
  description: string;
  href: string;
}

export function CommandMenu() {
  const [open, setOpen] = React.useState(false);
  const router = useRouter();

  // Example data - in real app, this could come from your registry
  const tools: Tool[] = [
    {
      name: "btc-price",
      category: "Crypto",
      description: "Get current Bitcoin price",
      href: "/registry/tools/btc-price",
    },
    {
      name: "sentiment",
      category: "Analysis",
      description: "Analyze text sentiment",
      href: "/registry/tools/sentiment",
    },
  ];

  const prompts: Prompt[] = [
    {
      name: "tweet",
      category: "Social",
      description: "Generate engaging tweets",
      href: "/registry/prompts/tweet",
    },
    {
      name: "blog-post",
      category: "Content",
      description: "Create blog post outline",
      href: "/registry/prompts/blog-post",
    },
  ];

  React.useEffect(() => {
    const down = (e: KeyboardEvent) => {
      if (e.key === "k" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        setOpen((open) => !open);
      }
    };
    document.addEventListener("keydown", down);
    return () => document.removeEventListener("keydown", down);
  }, []);

  const runCommand = React.useCallback((command: () => unknown) => {
    setOpen(false);
    command();
  }, []);

  return (
    <>
      <Button
        variant="outline"
        className="relative h-9 w-full justify-start rounded-[0.5rem] text-sm text-muted-foreground sm:pr-12 md:w-40 lg:w-64"
        onClick={() => setOpen(true)}
      >
        <span className="hidden lg:inline-flex">
          Search prompts and tools...
        </span>
        <span className="inline-flex lg:hidden">Search...</span>
        <kbd className="pointer-events-none absolute right-1.5 top-2 hidden h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex">
          <span className="text-xs">‚åò</span>K
        </kbd>
      </Button>
      <ShadcnCommandDialog open={open} onOpenChange={setOpen}>
        <ShadcnCommandInput placeholder="Type a command or search..." />
        <ShadcnCommandList>
          <ShadcnCommandEmpty>No results found.</ShadcnCommandEmpty>
          <ShadcnCommandGroup heading="Tools">
            {tools.map((tool) => (
              <CommandItem
                key={tool.name}
                value={tool.name}
                onSelect={() => {
                  runCommand(() => router.push(tool.href));
                }}
              >
                <Search className="mr-2 h-4 w-4" />
                <span>{tool.name}</span>
                <span className="ml-2 text-muted-foreground">
                  {tool.description}
                </span>
              </CommandItem>
            ))}
          </ShadcnCommandGroup>
          <ShadcnCommandSeparator />
          <ShadcnCommandGroup heading="Prompts">
            {prompts.map((prompt) => (
              <CommandItem
                key={prompt.name}
                value={prompt.name}
                onSelect={() => {
                  runCommand(() => router.push(prompt.href));
                }}
              >
                <Search className="mr-2 h-4 w-4" />
                <span>{prompt.name}</span>
                <span className="ml-2 text-muted-foreground">
                  {prompt.description}
                </span>
              </CommandItem>
            ))}
          </ShadcnCommandGroup>
          <ShadcnCommandSeparator />
          <ShadcnCommandGroup heading="Navigation">
            <ShadcnCommandItem
              onSelect={() => {
                runCommand(() => router.push("/docs"));
              }}
            >
              <CreditCard className="mr-2 h-4 w-4" />
              Documentation
            </ShadcnCommandItem>
            <ShadcnCommandItem
              onSelect={() => {
                runCommand(() => router.push("/examples"));
              }}
            >
              <Settings className="mr-2 h-4 w-4" />
              Examples
            </ShadcnCommandItem>
          </ShadcnCommandGroup>
        </ShadcnCommandList>
      </ShadcnCommandDialog>
    </>
  );
}
import { CopyBlock } from "@/components/copy-block";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { BaseAIItem, SpecializedPrompt, Tool } from "@/types/registry";

interface PromptDisplayProps {
  item: BaseAIItem | SpecializedPrompt | Tool;
}

export function PromptDisplay({ item }: PromptDisplayProps) {
  if (!("template" in item)) {
    return null;
  }

  // Generate the importable prompt code
  const promptCode = `import { ${item.id} } from "@/ai/prompts/${item.id}";

export const ${item.id} = {
  ${item.template}
}`;

  // Generate the usage example
  const usageCode = `import { ${item.id} } from "@/prompts/${item.id}";
`;

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">{item.name}</h1>
          <p className="text-lg text-muted-foreground">{item.description}</p>
        </div>
        <div className="flex items-center gap-2">
          <Badge variant={item.type === "base" ? "default" : "secondary"}>
            {item.type}
          </Badge>
          {item.type === "specialized" && (
            <Badge variant="outline">
              extends: {(item as SpecializedPrompt).extends}
            </Badge>
          )}
        </div>
      </div>

      <Tabs defaultValue="installation">
        <TabsList>
          <TabsTrigger value="installation">Installation</TabsTrigger>
          <TabsTrigger value="usage">Usage</TabsTrigger>
          {item.type === "specialized" && (
            <TabsTrigger value="tools">Compatible Tools</TabsTrigger>
          )}
        </TabsList>

        <TabsContent value="installation" className="space-y-4">
          <div className="rounded-md border p-4">
            <h3 className="mb-2 font-medium">Create prompt file</h3>
            <p className="text-sm text-muted-foreground mb-4">
              Copy and paste the following code into{" "}
              <code className="text-sm">prompts/{item.id}.ts</code>
            </p>
            <CopyBlock content={promptCode} language="typescript" />
          </div>
        </TabsContent>

        <TabsContent value="usage" className="space-y-4">
          <div className="rounded-md border p-4">
            <h3 className="mb-2 font-medium">Usage Example</h3>
            <CopyBlock content={usageCode} language="typescript" />
          </div>
        </TabsContent>

        {item.type === "specialized" && (
          <TabsContent value="tools" className="space-y-4">
            <div className="rounded-md border p-4">
              <h3 className="mb-2 font-medium">Compatible Tools</h3>
              <ul className="list-disc list-inside">
                {(item as SpecializedPrompt).suggestedTools.map((toolId) => (
                  <li key={toolId}>{toolId}</li>
                ))}
              </ul>
            </div>
          </TabsContent>
        )}
      </Tabs>
    </div>
  );
}
import { z } from "zod";

// Base message format for prompts
export interface PromptMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

// Prompt variables interface
export interface PromptVariables {
  [key: string]: string | number | boolean;
}

// Base registry item interface
export interface BaseAIItem {
  id: string;
  name: string;
  description: string;
  version?: string;
  type: "base";
  template: string;
  variables?: PromptVariables;
  examples: Array<{
    input: Record<string, unknown>;
    output: string;
    tools?: Record<string, unknown>;
  }>;
}

// Specialized prompt type
export interface SpecializedPrompt extends Omit<BaseAIItem, "type"> {
  type: "specialized";
  extends: string;
  suggestedTools: string[];
  template: string;
  variables?: PromptVariables;
}

// Tool type
export interface Tool {
  id: string;
  name: string;
  description: string;
  version?: string;
  type: "tool";
  category: string;
  configSchema: z.ZodType;
  outputSchema: z.ZodType;
  handler: (context: {
    config: Record<string, unknown>;
    metadata?: Record<string, unknown>;
  }) => Promise<unknown>;
  examples: Array<{
    config: Record<string, unknown>;
    result: unknown;
  }>;
}

// Prompt-Tool Pairing interface
export interface PromptToolPairing {
  promptId: string;
  toolIds: string[];
  description: string;
  examples: Array<{
    tools: Record<string, unknown>;
    input: Record<string, unknown>;
    output: string;
  }>;
}

// Union type for all registry items
export type RegistryItemType = BaseAIItem | SpecializedPrompt | Tool;

// Type guard for checking if an item is a prompt
export function isPrompt(
  item: RegistryItemType
): item is BaseAIItem | SpecializedPrompt {
  return item.type === "base" || item.type === "specialized";
}

// Type guard for checking if an item is a specialized prompt
export function isSpecializedPrompt(
  item: RegistryItemType
): item is SpecializedPrompt {
  return item.type === "specialized";
}

// Type guard for checking if an item is a tool
export function isTool(item: RegistryItemType): item is Tool {
  return item.type === "tool";
}

// Validation result interface
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

// Prompt builder configuration
export interface PromptBuilderConfig {
  validateOnBuild?: boolean;
  throwOnWarnings?: boolean;
  allowEmptyContent?: boolean;
}

// Built prompt result
export interface BuiltPrompt {
  messages: PromptMessage[];
  metadata?: Record<string, unknown>;
}

// Store interface
export interface RegistryStore {
  basePrompts: BaseAIItem[];
  specializedPrompts: SpecializedPrompt[];
  tools: Tool[];
  loading: boolean;
  error: string | null;
  fetchRegistry: () => Promise<void>;
}

// Navigation item interface
export interface NavItem {
  href: string;
  label: string;
  badge?: string;
  icon?: React.ComponentType<{ className?: string }>;
  description?: string;
}

// Navigation state interface
export interface NavigationState {
  basePromptsNav: NavItem[];
  specializedPromptsNav: NavItem[];
  toolsNav: Record<string, NavItem[]>;
}

// Variable definition interface
export interface VariableDefinition {
  name: string;
  type: "string" | "number" | "boolean";
  description?: string;
  required?: boolean;
  default?: unknown;
}

// Prompt template metadata
export interface PromptTemplateMetadata {
  variables: VariableDefinition[];
  description?: string;
  version?: string;
}

// Utility type for type-safe tool configuration
export type ToolConfig<T extends Tool> = z.infer<T["configSchema"]>;

// Utility type for type-safe tool output
export type ToolOutput<T extends Tool> = z.infer<T["outputSchema"]>;
import { NavigationState, NavItem } from "@/types/registry";
import { basePrompts, specializedPrompts, tools } from "@fatduckai/core";

export function useNavigation(): NavigationState {
  const basePromptsNav = basePrompts.map((prompt) => ({
    href: `/registry/prompts/${encodeURIComponent(prompt.id)}`,
    label: prompt.name,
  }));

  const specializedPromptsNav = specializedPrompts.map((prompt) => ({
    href: `/registry/prompts/${encodeURIComponent(prompt.id)}`,
    label: prompt.name,
    badge: prompt.extends,
  }));

  const toolsNav = tools.reduce((acc, tool) => {
    if (!acc[tool.category]) {
      acc[tool.category] = [];
    }
    acc[tool.category].push({
      href: `/registry/tools/${tool.id}`,
      label: tool.name,
    });
    return acc;
  }, {} as Record<string, NavItem[]>);

  return {
    basePromptsNav,
    specializedPromptsNav,
    toolsNav,
  };
}
import { SiteHeader } from "@/components/site-header";
import { ThemeProvider } from "@/components/theme-provider";
import "./globals.css";
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head />
      <body>
        <ThemeProvider defaultTheme="system" storageKey="ai-templates-theme">
          <div className="relative flex min-h-screen flex-col mx-auto px-10">
            <SiteHeader />
            <div className="flex-1">{children}</div>
          </div>
        </ThemeProvider>
      </body>
    </html>
  );
}
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #6a737d;
}

.token.namespace {
  opacity: 0.7;
}

.token.string,
.token.attr-value {
  color: #032f62;
}

.token.punctuation,
.token.operator {
  color: #393a34;
}

.token.entity,
.token.url,
.token.symbol,
.token.number,
.token.boolean,
.token.variable,
.token.constant,
.token.property,
.token.regex,
.token.inserted {
  color: #36acaa;
}

.token.atrule,
.token.keyword,
.token.attr-name {
  color: #00a4db;
}

.token.function,
.token.deleted {
  color: #d73a49;
}

.token.tag,
.token.selector {
  color: #00009f;
}

.token.important,
.token.function,
.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}

.dark .token.comment,
.dark .token.prolog,
.dark .token.doctype,
.dark .token.cdata {
  color: #8b949e;
}

.dark .token.string,
.dark .token.attr-value {
  color: #a5d6ff;
}

.dark .token.punctuation,
.dark .token.operator {
  color: #79c0ff;
}

.dark .token.entity,
.dark .token.url,
.dark .token.symbol,
.dark .token.number,
.dark .token.boolean,
.dark .token.variable,
.dark .token.constant,
.dark .token.property,
.dark .token.regex,
.dark .token.inserted {
  color: #a5d6ff;
}

.dark .token.atrule,
.dark .token.keyword,
.dark .token.attr-name {
  color: #7ee787;
}

.dark .token.function,
.dark .token.deleted {
  color: #ff7b72;
}

.dark .token.tag,
.dark .token.selector {
  color: #79c0ff;
}
import { Hero } from "@/components/hero";

export default function IndexPage() {
  return <Hero />;
}
import { DocLayout } from "@/components/doc-layout";

export default function ToolsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <DocLayout>{children}</DocLayout>;
}
import { RegistryItem } from "@/components/registry-item";
import { getToolById } from "@fatduckai/core";
import { notFound } from "next/navigation";

export default async function ToolPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const id = (await params).id;

  const tool = getToolById(id);

  if (!tool) {
    notFound();
  }

  return <RegistryItem item={tool} />;
}
import { ToolCard } from "@/components/tool-card";
import { groupByCategory } from "@/lib/utils";
import { tools } from "@fatduckai/core";

export default function ToolsPage() {
  const categorizedTools = groupByCategory(tools);

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold mb-4">Tools</h1>
        <p className="text-lg text-muted-foreground mb-8">
          Browse our collection of utility functions and integrations for
          enhancing AI responses.
        </p>
      </div>

      {Object.entries(categorizedTools).map(([category, categoryTools]) => (
        <section key={category}>
          <h2 className="text-2xl font-semibold mb-4 capitalize">{category}</h2>
          <div className="grid gap-4 md:grid-cols-2">
            {categoryTools.map((tool) => (
              <ToolCard
                key={tool.id}
                toolId={tool.id}
                showCompatibility={true}
              />
            ))}
          </div>
        </section>
      ))}
    </div>
  );
}
import { DocLayout } from "@/components/doc-layout";

export default function PromptsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <DocLayout>{children}</DocLayout>;
}
import { RegistryItem } from "@/components/registry-item";
import { getPromptById } from "@fatduckai/core";
import { notFound } from "next/navigation";

export default async function PromptPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const id = (await params).id;
  const prompt = await getPromptById(id);

  if (!prompt) {
    notFound();
  }

  return <RegistryItem item={prompt} />;
}
import { Badge } from "@/components/ui/badge";
import { Card } from "@/components/ui/card";
import { basePrompts, specializedPrompts } from "@fatduckai/core";
import Link from "next/link";

export default function PromptsPage() {
  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold mb-4">Prompts</h1>
        <p className="text-lg text-muted-foreground mb-8">
          Pre-built and specialized prompts for various use cases.
        </p>
      </div>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Base Prompts</h2>
        <div className="grid gap-4 md:grid-cols-2">
          {basePrompts.map((prompt) => (
            <Link key={prompt.id} href={`/registry/prompts/${prompt.id}`}>
              <Card className="p-4 hover:bg-muted/50 transition-colors">
                <h3 className="font-medium mb-1">{prompt.name}</h3>
                <p className="text-sm text-muted-foreground mb-2">
                  {prompt.description}
                </p>
                <div className="flex gap-2">
                  <Badge>base</Badge>
                  {prompt.version && (
                    <Badge variant="outline">v{prompt.version}</Badge>
                  )}
                </div>
              </Card>
            </Link>
          ))}
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-semibold mb-4">Specialized Prompts</h2>
        <div className="grid gap-4 md:grid-cols-2">
          {specializedPrompts.map((prompt) => (
            <Link key={prompt.id} href={`/registry/prompts/${prompt.id}`}>
              <Card className="p-4 hover:bg-muted/50 transition-colors">
                <h3 className="font-medium mb-1">{prompt.name}</h3>
                <p className="text-sm text-muted-foreground mb-2">
                  {prompt.description}
                </p>
                <div className="flex gap-2">
                  <Badge variant="secondary">specialized</Badge>
                  <Badge variant="outline">extends: {prompt.extends}</Badge>
                </div>
              </Card>
            </Link>
          ))}
        </div>
      </section>
    </div>
  );
}
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
export * from "./prompts";
export * from "./tools";
export * from "./types";
/// <reference types="node" />
import { Telegraf } from "telegraf";
import { CallbackHandler } from "./handlers/callbackHandler";
import { CommandHandler } from "./handlers/commandHandler";
import { MessageHandler } from "./handlers/message-handler";

export interface TelegramConfig {
  token: string;
  allowGroups?: boolean;
  commands?: string[];
}

export class TelegramClient {
  private bot: Telegraf;
  private messageHandler: MessageHandler;
  private commandHandler: CommandHandler;
  private callbackHandler: CallbackHandler;

  constructor(config: TelegramConfig) {
    if (!config.token) {
      throw new Error("TELEGRAM_BOT_TOKEN is required");
    }

    this.bot = new Telegraf(config.token);
    this.messageHandler = new MessageHandler();
    this.commandHandler = new CommandHandler();
    this.callbackHandler = new CallbackHandler();

    this.setupMiddleware();
    this.setupHandlers();
  }

  private setupMiddleware() {
    // Log all updates
    this.bot.use(async (ctx, next) => {
      const start = Date.now();
      await next();
      const ms = Date.now() - start;
      console.log("Response time: %sms", ms);
    });
  }

  private setupHandlers() {
    // Handle messages
    this.bot.on("message", (ctx) => this.messageHandler.handle(ctx));

    // Handle commands
    this.bot.command("start", (ctx) => this.commandHandler.handleStart(ctx));
    this.bot.command("help", (ctx) => this.commandHandler.handleHelp(ctx));

    // Handle callback queries
    this.bot.on("callback_query", (ctx) => this.callbackHandler.handle(ctx));
  }

  public async start() {
    try {
      await this.bot.launch();
      console.log("üöÄ Telegram bot started successfully");

      // Enable graceful shutdown
      process.once("SIGINT", () => this.stop("SIGINT"));
      process.once("SIGTERM", () => this.stop("SIGTERM"));
    } catch (error) {
      console.error("Failed to start Telegram bot:", error);
      throw error;
    }
  }

  public stop(signal?: string) {
    if (signal) {
      console.log(`Received ${signal}`);
    }
    this.bot.stop();
  }
}
import { Tool } from "../types";
import { btcPriceTool } from "./btc-price";

export const tools: Tool[] = [btcPriceTool];

export function getToolById(id: string): Tool | undefined {
  return tools.find((tool) => tool.id === id);
}
import { z } from "zod";
import { type Tool } from "../../types";

export const btcPriceTool: Tool = {
  id: "btc-price",
  type: "tool", // Added missing type property
  name: "Bitcoin Price",
  description: "Get current Bitcoin price",
  category: "crypto",
  configSchema: z.object({
    currency: z.enum(["USD", "EUR", "GBP"]).default("USD"),
    precision: z.number().min(0).max(2).default(2),
  }),
  outputSchema: z.object({
    price: z.string(),
    currency: z.enum(["USD", "EUR", "GBP"]),
    timestamp: z.string(),
  }),
  handler: async ({ config }) => {
    // Implementation remains the same
    return {
      price: "42500.00",
      currency: config.currency,
      timestamp: new Date().toISOString(),
    };
  },
  examples: [
    {
      config: {
        currency: "USD",
        precision: 2,
      },
      result: {
        price: "42500.00",
        currency: "USD",
        timestamp: new Date().toISOString(),
      },
    },
  ],
};
import { z } from "zod";

// Base message format for prompts
export interface PromptMessage {
  role: "system" | "user" | "assistant";
  content: string;
}

export interface PromptVariables {
  [key: string]: string | number | boolean;
}

export interface BaseAIItem {
  id: string;
  name: string;
  description: string;
  version?: string;
  type: "base";
  template: string;
  variables?: PromptVariables;
  examples: Array<{
    input: Record<string, unknown>;
    output: string;
    tools?: Record<string, unknown>;
  }>;
}

export interface SpecializedPrompt extends Omit<BaseAIItem, "type"> {
  type: "specialized";
  extends: string;
  suggestedTools: string[];
  template: string;
  variables?: PromptVariables;
}

export interface Tool {
  id: string;
  name: string;
  description: string;
  version?: string;
  type: "tool";
  category: string;
  configSchema: z.ZodType;
  outputSchema: z.ZodType;
  handler: (context: {
    config: Record<string, unknown>;
    metadata?: Record<string, unknown>;
  }) => Promise<unknown>;
  examples: Array<{
    config: Record<string, unknown>;
    result: unknown;
  }>;
}

export interface PromptToolPairing {
  promptId: string;
  toolIds: string[];
  description: string;
  examples: Array<{
    tools: Record<string, unknown>;
    input: Record<string, unknown>;
    output: string;
  }>;
}

export type RegistryItemType = BaseAIItem | SpecializedPrompt | Tool;

export function isPrompt(
  item: RegistryItemType
): item is BaseAIItem | SpecializedPrompt {
  return item.type === "base" || item.type === "specialized";
}

export function isSpecializedPrompt(
  item: RegistryItemType
): item is SpecializedPrompt {
  return item.type === "specialized";
}

export function isTool(item: RegistryItemType): item is Tool {
  return item.type === "tool";
}
import { BaseAIItem, SpecializedPrompt } from "../types";
import { tweetBasePrompt } from "./base/tweet";
import { cryptoTweetPrompt } from "./specialized/crypto-tweet";

export const basePrompts: BaseAIItem[] = [
  tweetBasePrompt,
  // Add other base prompts here
];

export const specializedPrompts: SpecializedPrompt[] = [
  cryptoTweetPrompt,
  // Add other specialized prompts here
];

export function getPromptById(
  id: string
): BaseAIItem | SpecializedPrompt | undefined {
  return [...basePrompts, ...specializedPrompts].find((p) => p.id === id);
}
export { cryptoTweetPrompt } from "./crypto-tweet";
import { SpecializedPrompt } from "../../types";

const CRYPTO_TWEET_TEMPLATE = `
<system>
You are a cryptocurrency expert creating engaging tweets.

Available data:
- BTC Price: <btc_price>
- Market Sentiment: <market_sentiment>
- Price emphasis: <priceEmphasis>

Requirements:
- Include current price data if available
- Mention market sentiment/momentum
- Use relevant crypto hashtags
- Maximum 280 characters
</system>

<user>Generate a crypto-focused tweet about: <topic></user>
`;

export const cryptoTweetPrompt: SpecializedPrompt = {
  id: "crypto-tweet",
  name: "Crypto Tweet",
  description: "Generate tweets with Coingecko price data",
  type: "specialized",
  extends: "tweet",
  template: CRYPTO_TWEET_TEMPLATE,
  suggestedTools: ["btc-price"],
  examples: [
    {
      input: {
        topic: "Bitcoin rally",
        priceEmphasis: "high",
      },
      tools: {
        btc_price: {
          price: "45000.00",
          currency: "USD",
        },
      },
      output:
        "üöÄ Bitcoin surges to $45,000! Strong momentum indicates growing institutional interest. The future of digital assets is here! #BTC #Crypto #Bitcoin",
    },
  ],
};
import { BaseAIItem } from "../../types";

const TWEET_TEMPLATE = `
<system>
You are a helpful assistant that generates engaging tweets.
Requirements:
- Tone: <tone>
- Include hashtags: <includeHashtags>
- Include emojis: <includeEmojis>
- Maximum 280 characters
- Engaging and conversational
- Relevant to the topic
</system>

<user>Generate a tweet about: <topic></user>
`;

export const tweetBasePrompt: BaseAIItem = {
  id: "tweet",
  name: "Tweet",
  description: "Base prompt for generating tweets",
  type: "base",
  template: TWEET_TEMPLATE,
  examples: [
    {
      input: {
        topic: "AI advancements",
        tone: "professional",
        includeHashtags: true,
        includeEmojis: true,
      },
      output:
        "ü§ñ Breakthrough in AI: Neural networks now show unprecedented learning capabilities in complex environments. Exciting times ahead! #AI #Innovation #TechNews",
    },
  ],
};
